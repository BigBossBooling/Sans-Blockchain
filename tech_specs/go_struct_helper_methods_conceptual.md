# DigiSocialBlock - Conceptual Go Helper Methods for Protocol Buffer Structs

**Document Version:** 1.0
**Date:** 2023-10-28 (Placeholder - will be updated by actual generation date)

## 1. Introduction

### 1.1. Purpose
This document outlines conceptual Go-specific helper methods that could be added to the Go structs generated by `protoc-gen-go` from the EchoNet (also referred to as DigiSocialBlock) `.proto` definitions (e.g., from `echonet_v3_core.proto`). The aim is to enhance developer experience, simplify common tasks, improve debuggability, and ensure consistent data handling beyond the standard methods provided by the Protobuf tooling.

### 1.2. Note on `protoc-gen-go` Output
The `protoc-gen-go` plugin already generates a rich set of methods for each message, including:
*   Getters for all fields.
*   Setters for non-oneof, non-repeated scalar fields (though direct field access is common in Go for generated structs).
*   `Marshal`, `Unmarshal`, `Merge`, `Size`, `Reset` methods.
*   `ProtoReflect()` for reflection-based operations.
*   `String()` for a basic string representation.

The helper methods proposed here are supplementary and aim to address specific operational or developer convenience needs within the EchoNet context.

## 2. General Principles for Helper Methods

*   **Separate Files:** Custom helper methods **MUST** be implemented in separate Go files (e.g., `nexus_user_object_v1_helpers.go`, or a common `core_types_helpers.go` within the same package as the generated types). This is crucial to prevent custom code from being overwritten when `.proto` files are recompiled and `.pb.go` files are regenerated.
*   **Focus:** Helper methods should primarily focus on:
    *   **Convenience:** Simplifying common or repetitive operations.
    *   **Representation:** Providing alternative representations (e.g., pretty JSON, summary strings).
    *   **Comparison:** Offering more nuanced comparison logic if needed.
    *   **Safe Access:** Providing safe ways to access or transform data, especially from `google.protobuf.Any` or complex nested structures.
*   **No Complex Business Logic:** Avoid embedding significant business logic directly into these data structure helper methods. Such logic belongs in service layers or DLI-native "contract" modules.
*   **Avoid Overriding Generated Methods:** Do not override methods generated by `protoc-gen-go` unless there is an extremely strong, well-justified reason, as this can lead to unexpected behavior and maintenance issues.
*   **Consistency:** Maintain consistency in naming conventions (e.g., `To<Format>`, `Is<Condition>`, `Get<SpecificField>`) and behavior across similar helper methods for different structs.
*   **Error Handling:** Helpers that can fail should return an `error` as the last argument, following Go conventions.

## 3. Identified Helper Method Categories & Specific Examples

Below are categories of potentially useful helper methods, with specific examples for core EchoNet data structures.

### 3.1. JSON Serialization/Deserialization (for Debugging/Logging)

While `protojson.Marshal` and `protojson.Unmarshal` exist, custom helpers can offer more control or pretty-printing.

*   **Target Struct(s):** Applicable to most core structs like `NexusContentObjectV1`, `NexusUserObjectV1`, `NexusInteractionRecordV1`, `WitnessProofV1`, etc.
*   **Example Method Signature (Conceptual Go syntax):**
    ```go
    // For NexusContentObjectV1
    func (m *NexusContentObjectV1) ToPrettyJSON() (string, error)
    func (m *NexusContentObjectV1) FromJSON(jsonData []byte) error // Less common for helpers, usually direct Unmarshal
    ```
*   **Purpose & Behavior:**
    *   `ToPrettyJSON()`: Serializes the Protobuf message to a human-readable, indented JSON string.
    *   `FromJSON()`: Deserializes a JSON string into the Protobuf message (potentially with specific unmarshaling options).
*   **Rationale:** Extremely useful for debugging, logging, creating test fixtures, and manual inspection of DLI state or events. Standard `String()` method is often too compact for complex objects.
*   **Implementation Notes (Conceptual):**
    *   `ToPrettyJSON()`: Use `prototransform.FormatPrint()` or `json.MarshalIndent` after converting to a map or using `protojson.MarshalOptions{Indent: "  "}`.
    *   Ensure proper handling of `google.protobuf.Any` and `google.protobuf.Timestamp` to standard JSON representations.

### 3.2. Deep Copy / Clone Methods

Protobuf messages are pointer types in Go. Direct assignment copies the pointer, not the underlying data. A `Clone` method provides a true deep copy.

*   **Target Struct(s):** All mutable core structs, e.g., `NexusContentObjectV1`, `NexusUserObjectV1`, `NexusInteractionRecordV1`, `CoreContentMetadataV1`.
*   **Example Method Signature (Conceptual Go syntax):**
    ```go
    // For NexusUserObjectV1
    func (m *NexusUserObjectV1) Clone() *NexusUserObjectV1
    ```
*   **Purpose & Behavior:** Creates a new instance of the struct and performs a deep copy of all fields, including nested messages and slices/maps.
*   **Rationale:** Essential when needing to modify a copy of a message without affecting the original, common in state management or before applying transformations. `proto.Clone()` from `google.golang.org/protobuf/proto` already provides this. This helper might just wrap it for discoverability or specific type assertion.
*   **Implementation Notes (Conceptual):**
    *   Leverage the standard `proto.Clone(m)` function from the `google.golang.org/protobuf/proto` package.
    *   The helper method would then cast the `proto.Message` back to the specific type:
        ```go
        // import "google.golang.org/protobuf/proto"
        func (m *NexusUserObjectV1) Clone() *NexusUserObjectV1 {
          if m == nil { return nil }
          return proto.Clone(m).(*NexusUserObjectV1)
        }
        ```

### 3.3. Comparison Methods (Beyond Basic Equality)

Sometimes, a more nuanced comparison than `proto.Equal()` is needed.

*   **Target Struct(s):** Structs where semantic equivalence might differ from strict byte-for-byte equality.
*   **Example Method Signature (Conceptual Go syntax):**
    ```go
    // For CoreContentMetadataV1
    func (m *CoreContentMetadataV1) IsSemanticallyEquivalent(other *CoreContentMetadataV1) bool
    ```
*   **Purpose & Behavior:** `IsSemanticallyEquivalent()` would compare two instances, potentially ignoring fields that don't affect the core meaning (e.g., a non-critical internal cache field, or comparing timestamps with a certain tolerance).
*   **Rationale:** Useful in tests or application logic where functional equivalence is more important than exact bitwise equality, especially if some fields are, for example, timestamps set at different stages of processing but still refer to the "same" logical object.
*   **Implementation Notes (Conceptual):**
    *   Requires careful, field-by-field comparison logic.
    *   Define clearly which fields are included/excluded or compared with tolerance.

### 3.4. Convenience Getters & Predicates for Nested or Complex Fields

*   **Target Struct(s):** Any struct with important nested data or flags.
*   **Example Method Signatures (Conceptual Go syntax):**
    ```go
    // For NexusUserObjectV1
    func (m *NexusUserObjectV1) IsWitnessActive() bool
    func (m *NexusUserObjectV1) GetPublicKeyForPurpose(purpose string) ([]byte, bool)

    // For NexusInteractionRecordV1
    func (m *NexusInteractionRecordV1) AsCommentPayload() (*CommentPayloadV1, error)
    func (m *NexusInteractionRecordV1) AsReactionPayload() (*ReactionPayloadV1, error)
    // ... other As<Type>Payload() methods

    // For WitnessProofV1
    func (m *WitnessProofV1) GetAttesterCount() int
    ```
*   **Purpose & Behavior:**
    *   `IsWitnessActive()`: Checks the `status_flags` bitmask for the "IsWitnessActive" flag.
    *   `GetPublicKeyForPurpose()`: Retrieves a specific public key from the `public_key_entries` map.
    *   `As<Type>Payload()`: Safely unpacks the `google.protobuf.Any` payload field into a specific known payload type (e.g., `CommentPayloadV1`). Returns an error if the type does not match.
    *   `GetAttesterCount()`: Returns the number of DIDs in `attesting_witness_dids`.
*   **Rationale:** Simplifies common checks and data extractions, making application code cleaner and less error-prone. Type-safe unpacking of `Any` is particularly useful.
*   **Implementation Notes (Conceptual):**
    *   `IsWitnessActive()`: Bitwise operations on `status_flags`. Requires global constants for flag values.
    *   `GetPublicKeyForPurpose()`: Simple map lookup.
    *   `As<Type>Payload()`: Use `payload.MessageIs(&ExpectedType{})` and `payload.UnmarshalTo(&ExpectedType{})` methods of `google.protobuf.Any`.
    *   `GetAttesterCount()`: `len(m.GetAttestingWitnessDids())`.

### 3.5. ID Generation / Hashing Helpers (If not part of a separate utility package)

While core hashing logic for `ContentID`, `interaction_id`, etc., might reside in dedicated utility packages (as per `tech_specs/content_hashing_timestamping_specs.md`), convenience methods on the structs themselves could call these utilities.

*   **Target Struct(s):** `NexusContentObjectV1`, `CoreContentMetadataV1`, `NexusInteractionRecordV1`.
*   **Example Method Signature (Conceptual Go syntax):**
    ```go
    // For CoreContentMetadataV1
    func (m *CoreContentMetadataV1) CalculateHash() ([]byte, error) // Returns core_metadata_hash

    // For NexusContentObjectV1 (assuming pre-image fields are set)
    func (m *NexusContentObjectV1) CalculateContentID() (string, error)
    ```
*   **Purpose & Behavior:** Provides a direct way to calculate the canonical hash or ID for an instance of the struct.
*   **Rationale:** Encapsulates the call to the more generic hashing utilities, ensuring the correct fields and canonicalization are used for that specific struct type. Useful for client-side ID generation before submission.
*   **Implementation Notes (Conceptual):**
    *   These methods would internally call the canonical serialization and hashing functions defined in `tech_specs/content_hashing_timestamping_specs.md`.
    *   Ensure all fields required for the pre-image are accessible and correctly formatted.

### 3.6. Validation Helpers

While full validation is a Witness responsibility, client-side or preliminary validation can be useful.

*   **Target Struct(s):** All core DLI structs.
*   **Example Method Signature (Conceptual Go syntax):**
    ```go
    // For NexusContentObjectV1
    func (m *NexusContentObjectV1) ValidateBasic() error
    ```
*   **Purpose & Behavior:** Performs basic client-side validation checks (e.g., required fields present, string lengths, DID format, timestamp plausibility) as conceptually noted in the `.proto` comments and `tech_specs`.
*   **Rationale:** Allows clients to catch basic errors before submitting events to the DLI, saving network resources and providing faster user feedback. This is distinct from the more rigorous DLI-consensus validation by Witnesses.
*   **Implementation Notes (Conceptual):**
    *   Implement checks based on the conceptual validation rules documented for each field.
    *   Return specific error types (from a shared error package) for different validation failures.

## 4. Non-Goals for Helper Methods (Reiteration)

*   **No complex business logic:** Keep these helpers focused on data manipulation, representation, or basic validation directly related to the struct's data.
*   **No overriding `protoc-gen-go` methods:** Unless an extremely compelling case exists and is well-documented.

## 5. Documentation of Helper Methods

*   All custom helper methods implemented **MUST** be thoroughly documented using GoDoc comments.
*   Documentation should clearly explain the method's purpose, behavior, parameters, return values, and any important assumptions or error conditions.

By thoughtfully adding such helper methods, the development experience using the core EchoNet Protobuf structs in Go can be significantly improved, leading to cleaner, more robust, and more maintainable application code.
